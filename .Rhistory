trueModel <- brm(chosen ~ V+ RU + VTU + (V+ RU + VTU| ID),
family = binomial(link = "probit"),
data = data,
chains = 2,
cores = 2,
iter = 10000)
} else if (model == "UCB") {
trueModel <- brm(chosen ~ V+ RU + (V+ RU | ID),
family = binomial(link = "probit"),
data = data,
chains = 2,
cores = 2,
iter = 10000)
}
} else {
if (model == "hybrid"){
trueModel <- glm(chosen ~ V+ RU + VTU,
data = data,
family = binomial(link = "probit"))
} else if (model == "UCB") {
trueModel <- glm(chosen ~ V+ RU,
data = data,
family = binomial(link = "probit"))
}
# save coefficients themselves if it is the subject-level model
trueParams <- data.frame(ID = unique(data$ID),
V = trueModel$coefficients[2],
RU = trueModel$coefficients[3],
converged = trueModel$converged)
if (model == "hybrid"){
trueParams$VTU[trueParams$ID == i] <- trueModel$coefficients[4]
}
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
return(output)
}
}
?fit_model_sam()
fit_model_sam(sam, "UCB", T)
get_KL_into_df <- function(data){
## add mean and variance from the Kalman Filter to the data frame
data$KLM0 <- NA
data$KLM1 <- NA
data$KLV0 <- NA
data$KLV1 <- NA
## get output of Kalman Filter into dataframe
for (i in unique(paste(data$ID, data$block))){
dat <- subset(data, paste(data$ID, data$block) == i)
# stable or fluctuating arms? -> get innovation variance based on this
if (dat$cond[1] == "FS") {xi <- c(4,0)
} else if (dat$cond[1] == "SF") {xi <- c(0,4)
} else if (dat$cond[1] == "FF") {xi <- c(4,4)
} else if (dat$cond[1] == "SS") {xi <- c(0,0)}
posterior <- kalman_learning(dat, 2, xi, 1)
data$KLM0[paste(data$ID, data$block) == i] <- posterior$m_1[1:10]
data$KLM1[paste(data$ID, data$block) == i] <- posterior$m_2[1:10]
data$KLV0[paste(data$ID, data$block) == i] <- posterior$v_1[1:10]
data$KLV1[paste(data$ID, data$block) == i] <- posterior$v_2[1:10]
}
data$V <- data$KLM0 - data$KLM1
data$RU <- getRU(data$KLV0, data$KLV1)
data$VTU <- data$V/(sqrt(data$KLV0 + data$KLV1))
return(data)
}
sam <- get_KL_into_df(sam)
View(sam)
fit_model_sam(sam, "UCB", T)
fit_model_sam(sam, "UCB", F)
out <-  fit_model_sam(sam, "UCB", F)
data <- sam
trueModel <- glm(chosen ~ V+ RU,
data = data,
family = binomial(link = "probit"))
# save coefficients themselves if it is the subject-level model
trueParams <- data.frame(ID = unique(data$ID),
V = trueModel$coefficients[2],
RU = trueModel$coefficients[3],
converged = trueModel$converged)
unique(data$ID)
fit_model_sam(sam[sam$ID == 1, ], "UCB", F)
out <- fit_model_sam(sam[sam$ID == 1, ], "UCB", F)
View(out)
data <- sam[sam$ID == 1, ]
unique(data$ID)
# save coefficients themselves if it is the subject-level model
trueParams <- data.frame(ID = unique(data$ID),
V = trueModel$coefficients[2],
RU = trueModel$coefficients[3],
converged = trueModel$converged)
View(trueParams)
hierarchical = F
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
list(trueModel, trueParams)
out <- list(trueModel, trueParams)
output <- ifelse(hierarchical == T, trueModel, list(trueModel, trueParams))
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
hierarchical = T
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
hierarchical = F
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
View(out)
output <- ifelse(hierarchical, trueModel, 1)
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
list(trueModel, trueParams)
output <- list(trueModel, trueParams)
output <- ifelse(hierarchical, trueModel, list(trueModel, trueParams))
if(hierarchical){output <- trueModel} else {output <- list(trueModel, trueParams)}
fit_model_sam(sam, "UCB", T)
fit_model_sam <- function(data, model, hierarchical){
#' fit model to data from Sam's task
#'
#' @description fits the type of model described by input to function to the data given to function
#' @param data data.frame containing all the task data
#' @param model string: UCB vs hybrid
#' @param hierarchical boolean; bayesian fitting or subject-level glm
#' @return list containing model object and if hierarchical == F also a data.frame with coefficients
if (hierarchical){
if (model == "hybrid"){
trueModel <- brm(chosen ~ V+ RU + VTU + (V+ RU + VTU| ID),
family = binomial(link = "probit"),
data = data,
chains = 2,
cores = 2,
iter = 10000)
} else if (model == "UCB") {
trueModel <- brm(chosen ~ V+ RU + (V+ RU | ID),
family = "bernoulli",
data = data,
chains = 2,
cores = 2,
iter = 10000)
}
} else {
if (model == "hybrid"){
trueModel <- glm(chosen ~ V+ RU + VTU,
data = data,
family = binomial(link = "probit"))
} else if (model == "UCB") {
trueModel <- glm(chosen ~ V+ RU,
data = data,
family = binomial(link = "probit"))
}
# save coefficients themselves if it is the subject-level model
trueParams <- data.frame(ID = unique(data$ID),
V = trueModel$coefficients[2],
RU = trueModel$coefficients[3],
converged = trueModel$converged)
if (model == "hybrid"){
trueParams$VTU[trueParams$ID == i] <- trueModel$coefficients[4]
}
if(hierarchical){output <- trueModel} else {output <- list(trueModel, trueParams)}
return(output)
}
}
fit_model_sam(sam, "UCB", T)
out <- fit_model_sam(sam, "UCB", T)
View(out)
out
recovery_sam <- function(data, model, hierarchical){
#' parameter recovery for data from Sam's task
#'
#' @description fits model to data; simulates data based on subjects' estimates; re-fits that data
#' @param data data.frame containing all the task data
#' @param model UCB, hybrid
#' @param hierarchical boolean; whether data are fit using brms or subject-level glms
#' @return a list containing a data.frame with subject-level estimates fitted to the observed data, a data.frame with the recovered estimates, a ggplot element plotting the recovery
# prep dataframe
trueParams <- data.frame(ID = unique(data$ID),
V = rep(NA, length(unique(data$ID))),
RU = rep(NA, length(unique(data$ID))),
converged = rep(NA, length(unique(data$ID))))
if (model == "hybrid"){
trueParams$VTU <- NA
}
simParams <- trueParams
blocks <- max(data$block)
trials <- max(data$trial)
nsubs <- 1 # bc we do 1 subject at a time
### fit model
if (hierarchical){
out <- fit_model_sam(data, model, T)
trueModel <- out[[1]]
trueParams <- out[[2]]
}
## iterate through subjects to simulate for each subject
for (i in unique(data$ID)){
if (i %% 10 == 0) {print(paste("subject", i, "of", max(data$ID)))}
### fit model
if (!hierarchical){
out <- fit_model_sam(data[data$ID == i, ], model, F)
trueParams[trueParams$ID == i, ] <- out[[2]]
trueModel <- out[[1]]
}
### simulate data
# create data
simdat <- sim_data_sam(data, trueModel, i)
if (!hierarchical) { # if it's not hierarchical then we do this for every subject separately, otherwise only in end
simParams[simParams$ID == i, ] <- fit_model_sam(simdat, model, F)[[2]]
}
}
params <- c("RU", "V")
if (model == "hybrid"){
params[3] <- "VTU"
}
## extract parameters for hierarchical
if (hierarchical){
simParams <- fit_model_sam(simdat, model, T)[[2]]
### get correlations for hierarchical
cors <- data.frame(true = rep(params, length(params)),
recovered =  rep(params, each = length(params)),
cor = NA)
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(trueParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[trueParams$predictor == cors$true[x]],
simParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[simParams$predictor == cors$recovered[x]]))
} else {
## get correlations for subject-level
simParams$bothConverged <- ifelse(simParams$converged & trueParams$converged, T, F)
trueParams$bothConverged <- simParams$bothConverged
cors <- data.frame(true = rep(params, length(params)),
recovered =  rep(params, each = length(params)),
cor = NA)
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(trueParams[trueParams$bothConverged,grep(cors$true[x], colnames(trueParams))[1]],# converged rows, cols with correct variable name (first instance)
simParams[simParams$bothConverged, grep(cors$recovered[x], colnames(simParams))[1]]))
}
# plot them
p <- ggplot(cors, aes(x = true, y = recovered, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + ggtitle(paste("Recovery of Sam's task using ", model))
return(list(trueParams, simParams, p))
}
source("analysis/recovery_utils.R")
library(tidyverse)
library(ggplot2)
library(jsonlite)
library(brms)
theme_set(theme_classic(base_size = 14))
setwd("/Users/kwitte/Documents/GitHub/exploration-psychometrics")
load("data/pilot/bandits.Rda")
sam <- get_KL_into_df(sam)
source("analysis/recovery_utils.R")
se<-function(x){sd(x, na.rm = T)/sqrt(length(na.omit(x)))}
meann <- function(x){mean(x, na.rm = T)}
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = F)
library(tidyverse)
library(ggplot2)
library(jsonlite)
library(brms)
theme_set(theme_classic(base_size = 14))
setwd("/Users/kwitte/Documents/GitHub/exploration-psychometrics")
load("data/pilot/bandits.Rda")
sam <- get_KL_into_df(sam)
source("analysis/recovery_utils.R")
se<-function(x){sd(x, na.rm = T)/sqrt(length(na.omit(x)))}
meann <- function(x){mean(x, na.rm = T)}
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = F)
res_list
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
?predict
library(brms)
?brms::predict.brmsfit
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
C <- brms::predict.brmsfit(trueModel, newdata = simdat[simdat$trial == t, ])
?brms::predict.brmsfit
C <- brms::predict(trueModel, newdata = simdat[simdat$trial == t, ])
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ])
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
data <- sam
out <- fit_model_sam(data, model, T)
trueModel <- out[[1]]
trueParams <- out[[2]]
model <- "UCB"
out <- fit_model_sam(data, model, T)
trueModel <- out[[1]]
trueParams <- out[[2]]
trueParams
out
source("analysis/recovery_utils.R")
out <- fit_model_sam(data, model, T)
trueModel <- out[[1]]
trueParams <- out[[2]]
View(trueParams)
View(trueModel)
id <- 1
simdat <- subset(data, ID == id, -c(chosen, V, RU, KLM0, KLM1, KLV0, KLV1, reward, reward1, reward2))
blocks <- max(simdat$block)
trials <- max(simdat$trial)
## create rewards
simdat$reward1[simdat$trial == 1] <- sample(data$reward1, blocks, replace = T)
simdat$reward2[simdat$trial == 1] <- sample(data$reward2, blocks, replace = T)
# cond: experiment condition. 1:Fluctuating/Stable; 2:SF; 3:FF; 4:SS
# stable condition:
# sample a value for each first trial and repeat it for the rest of the trials
simdat$reward1[simdat$cond == "SS" | simdat$cond == "SF"] <- rep(sample(data$reward1, nrow(simdat[(simdat$cond == "SS" | simdat$cond == "SF") & simdat$trial == 1, ]), replace = T), each = trials)
simdat$reward2[ simdat$cond == "SS" | simdat$cond == "FS"] <- rep(sample(data$reward2, nrow(simdat[(simdat$cond == "FS" | simdat$cond == "SS")& simdat$trial == 1, ]), replace = T), each = trials)
# random walk
for (j in 2:trials){
simdat$reward1[simdat$trial == j & (simdat$cond == "FS" | simdat$cond == "FF")] <- rnorm(1,simdat$reward1[simdat$trial == j-1 & (simdat$cond == "FS" | simdat$cond == "FF")],4)
simdat$reward2[simdat$trial == j & (simdat$cond == "SF" | simdat$cond == "FF")] <- rnorm(1,simdat$reward2[simdat$trial == j-1 & (simdat$cond == "SF" | simdat$cond == "FF")],4)
}
# add noise
noise <- rnorm(trials*blocks, 0, 1)
simdat$reward1 <- simdat$reward1 + noise
noise <- rnorm(trials*blocks, 0, 1)
simdat$reward2 <- simdat$reward2 + noise
## iteratively make choices
# learning part initialisations
m0 <- 0
v0 <- 100
no <- 2
sigma_epsilon_sq <- 1
# sigma xi sq depends on the condition 1:Fluctuating/Stable; 2:SF; 3:FF; 4:SS
sigma_xi_sq <- matrix(NA, ncol = 2, nrow = blocks)
sigma_xi_sq[ ,1] <- apply(as.array(simdat$cond[simdat$trial == 1]), 1, function(x) ifelse(x == "FS" | x == "FF", 4, 0))
sigma_xi_sq[ ,2] <- apply(as.array(simdat$cond[simdat$trial == 1]), 1, function(x) ifelse(x == "SF" | x == "FF", 4, 0))
# get initial posterior mean and variance for each option
m <- matrix(0, ncol = no, nrow = nrow(simdat)) # to hold the posterior means
v <- matrix(100, ncol = no, nrow = nrow(simdat)) # to hold the posterior variances
# get initial V and RU
simdat$V[simdat$trial == 1] <- 0
simdat$RU[simdat$trial == 1] <- 0
simdat$VTU[simdat$trial == 1] <- 0
for(t in 1:trials) {
# get choice
if (bootstrapped) {
C <- trueModel$V[i] * simdat$V[t] + trueModel$RU[i] * simdat$RU[t]
} else {
if (hierarchical){
library(brms)
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ])
} else{
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ] , type = "response")
}
}
C <- ifelse(runif(length(C)) < C, 1, 0)
simdat$C[simdat$trial == t] <- C
# get reward
reward <- ifelse(C == 0, simdat$reward1[simdat$trial == t], simdat$reward2[simdat$trial == t])
# set the Kalman gain for the chosen option
# sigma xi differs between options so need to index it
kt <- matrix(0, ncol = no, nrow = blocks)
# indexing doesn't really work if not consistently same column so the _chosen thing is my akward workaround
v_chosen <- ifelse(C == 0, v[simdat$trial == t, 1], v[simdat$trial == t, 2])
sigma_xi_chosen <-  ifelse(C == 0, sigma_xi_sq[ , 1], sigma_xi_sq[ ,2])
kt_chosen <- (v_chosen + sigma_xi_chosen)/(v_chosen + sigma_epsilon_sq + sigma_xi_chosen)
kt[ ,1] <- ifelse(C == 0, kt_chosen, 0)
kt[ ,2] <- ifelse(C == 1, kt_chosen, 0)
# compute the posterior means
m[simdat$trial == (t+1),] <- m[simdat$trial == t,] + kt*(reward - m[simdat$trial == t,])
# compute the posterior variances
v[simdat$trial == (t+1), ] <- (1-kt)*(v[simdat$trial == t,]) + sigma_xi_sq
# compute V and RU
simdat$V[simdat$trial == (t+1)] <- getV(m[simdat$trial == (t+1),1], m[simdat$trial == (t+1),2])
simdat$RU[simdat$trial == (t+1)] <- getRU(v[simdat$trial == (t+1),1], v[simdat$trial == (t+1),2])
simdat$VTU[simdat$trial == (t+1)] <- simdat$V[simdat$trial == (t+1)]/(sqrt(v[simdat$trial == (t+1),1] + v[simdat$trial == (t+1),2]))
simdat$chosen <- simdat$C
}
t == 1
t = 1
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ])
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ])
simdat[simdat$trial == t, ]
newdata = simdat[simdat$trial == t, ]
View(newdata)
View(simdat)
View(C)
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
# create data
simdat <- sim_data_sam(data, trueModel, i, hierarchical= hierarchical)
i <- 1
# create data
simdat <- sim_data_sam(data, trueModel, i, hierarchical= hierarchical)
sim_data_sam <- function(data, trueModel, i, bootstrapped = F, hierarchical = F) {
#' simulate data for sam's task from whatever model
#'
#' @description simulates choices for a particular subject in a trial-by-trial fashion
#' @param data original data from that entire task
#' @param trueModel Model fit to true choices of that subject
#' @param i index of subject to simulate data for
#' @param bootstrapped boolean, if T, trueModel is simply the parameter estimates to build an equation from
#' @return data.frame with simulated data for that subject
id <- ifelse(bootstrapped, 1, i)
simdat <- subset(data, ID == id, -c(chosen, V, RU, KLM0, KLM1, KLV0, KLV1, reward, reward1, reward2))
blocks <- max(simdat$block)
trials <- max(simdat$trial)
## create rewards
simdat$reward1[simdat$trial == 1] <- sample(data$reward1, blocks, replace = T)
simdat$reward2[simdat$trial == 1] <- sample(data$reward2, blocks, replace = T)
# cond: experiment condition. 1:Fluctuating/Stable; 2:SF; 3:FF; 4:SS
# stable condition:
# sample a value for each first trial and repeat it for the rest of the trials
simdat$reward1[simdat$cond == "SS" | simdat$cond == "SF"] <- rep(sample(data$reward1, nrow(simdat[(simdat$cond == "SS" | simdat$cond == "SF") & simdat$trial == 1, ]), replace = T), each = trials)
simdat$reward2[ simdat$cond == "SS" | simdat$cond == "FS"] <- rep(sample(data$reward2, nrow(simdat[(simdat$cond == "FS" | simdat$cond == "SS")& simdat$trial == 1, ]), replace = T), each = trials)
# random walk
for (j in 2:trials){
simdat$reward1[simdat$trial == j & (simdat$cond == "FS" | simdat$cond == "FF")] <- rnorm(1,simdat$reward1[simdat$trial == j-1 & (simdat$cond == "FS" | simdat$cond == "FF")],4)
simdat$reward2[simdat$trial == j & (simdat$cond == "SF" | simdat$cond == "FF")] <- rnorm(1,simdat$reward2[simdat$trial == j-1 & (simdat$cond == "SF" | simdat$cond == "FF")],4)
}
# add noise
noise <- rnorm(trials*blocks, 0, 1)
simdat$reward1 <- simdat$reward1 + noise
noise <- rnorm(trials*blocks, 0, 1)
simdat$reward2 <- simdat$reward2 + noise
## iteratively make choices
# learning part initialisations
m0 <- 0
v0 <- 100
no <- 2
sigma_epsilon_sq <- 1
# sigma xi sq depends on the condition 1:Fluctuating/Stable; 2:SF; 3:FF; 4:SS
sigma_xi_sq <- matrix(NA, ncol = 2, nrow = blocks)
sigma_xi_sq[ ,1] <- apply(as.array(simdat$cond[simdat$trial == 1]), 1, function(x) ifelse(x == "FS" | x == "FF", 4, 0))
sigma_xi_sq[ ,2] <- apply(as.array(simdat$cond[simdat$trial == 1]), 1, function(x) ifelse(x == "SF" | x == "FF", 4, 0))
# get initial posterior mean and variance for each option
m <- matrix(0, ncol = no, nrow = nrow(simdat)) # to hold the posterior means
v <- matrix(100, ncol = no, nrow = nrow(simdat)) # to hold the posterior variances
# get initial V and RU
simdat$V[simdat$trial == 1] <- 0
simdat$RU[simdat$trial == 1] <- 0
simdat$VTU[simdat$trial == 1] <- 0
for(t in 1:trials) {
# get choice
if (bootstrapped) {
C <- trueModel$V[i] * simdat$V[t] + trueModel$RU[i] * simdat$RU[t]
} else {
if (hierarchical){
library(brms)
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ])[ ,1]
} else{
C <- predict(trueModel, newdata = simdat[simdat$trial == t, ] , type = "response")
}
}
C <- ifelse(runif(length(C)) < C, 1, 0)
simdat$C[simdat$trial == t] <- C
# get reward
reward <- ifelse(C == 0, simdat$reward1[simdat$trial == t], simdat$reward2[simdat$trial == t])
# set the Kalman gain for the chosen option
# sigma xi differs between options so need to index it
kt <- matrix(0, ncol = no, nrow = blocks)
# indexing doesn't really work if not consistently same column so the _chosen thing is my akward workaround
v_chosen <- ifelse(C == 0, v[simdat$trial == t, 1], v[simdat$trial == t, 2])
sigma_xi_chosen <-  ifelse(C == 0, sigma_xi_sq[ , 1], sigma_xi_sq[ ,2])
kt_chosen <- (v_chosen + sigma_xi_chosen)/(v_chosen + sigma_epsilon_sq + sigma_xi_chosen)
kt[ ,1] <- ifelse(C == 0, kt_chosen, 0)
kt[ ,2] <- ifelse(C == 1, kt_chosen, 0)
# compute the posterior means
m[simdat$trial == (t+1),] <- m[simdat$trial == t,] + kt*(reward - m[simdat$trial == t,])
# compute the posterior variances
v[simdat$trial == (t+1), ] <- (1-kt)*(v[simdat$trial == t,]) + sigma_xi_sq
# compute V and RU
simdat$V[simdat$trial == (t+1)] <- getV(m[simdat$trial == (t+1),1], m[simdat$trial == (t+1),2])
simdat$RU[simdat$trial == (t+1)] <- getRU(v[simdat$trial == (t+1),1], v[simdat$trial == (t+1),2])
simdat$VTU[simdat$trial == (t+1)] <- simdat$V[simdat$trial == (t+1)]/(sqrt(v[simdat$trial == (t+1),1] + v[simdat$trial == (t+1),2]))
simdat$chosen <- simdat$C
}
simdat$C <- as.integer(simdat$C)
return(simdat)
}
# create data
simdat <- sim_data_sam(data, trueModel, i, hierarchical= hierarchical)
hierarchical = T
# create data
simdat <- sim_data_sam(data, trueModel, i, hierarchical= hierarchical)
params <- c("RU", "V")
simParams <- fit_model_sam(simdat, model, T)[[2]]
View(trueParams)
cors <- data.frame(true = rep(params, length(params)),
recovered =  rep(params, each = length(params)),
cor = NA)
View(cors)
View(simParams)
simdatCollect <- data.frame()
simdatCollect <- rbind(simdatCollect, simdat)
View(simdat)
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "UCB", hierarchical = T)
res_list
# get parameters fitted to actual data
trueParams <- res_list[[1]]
# get parameters fitted to simulated data
simParams <- res_list[[2]]
pars <- rbind(trueParams, simParams)
pars$estimate <- pars$`colMeans(as.data.frame(posterior_samples(trueModel)))`
pars$source <- rep(c("observed", "recovered"), each = nrow(pars)/2)
ggplot(pars, aes(estimate, fill = source)) + geom_histogram(alpha = 0.5, position = "identity") + facet_wrap(vars(predictor), scale= "free")
cor(trueParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[trueParams$predictor == "V"], simParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[simParams$predictor == "V"])
cor(trueParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[trueParams$predictor == "V"], simParams$`colMeans(as.data.frame(posterior_samples(trueModel)))`[simParams$predictor == "RU"])
## hybrid model
res_list <- recovery_sam(sam, "hybrid", hierarchical = T)
source("analysis/recovery_utils.R")
## hybrid model
res_list <- recovery_sam(sam, "hybrid", hierarchical = T)
res_list
# get parameters fitted to actual data
trueParams <- res_list[[1]]
# get parameters fitted to simulated data
simParams <- res_list[[2]]
# view recovery plot
res_list[[3]]
pars <- rbind(trueParams, simParams)
pars$estimate <- pars$`colMeans(as.data.frame(posterior_samples(trueModel)))`
pars$source <- rep(c("observed", "recovered"), each = nrow(pars)/2)
ggplot(pars, aes(estimate, fill = source)) + geom_histogram(alpha = 0.5, position = "identity") + facet_wrap(vars(predictor), scale= "free")

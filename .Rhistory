Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(MAKEFLAGS = "-j4") # four cores used
install.packages(c("Rcpp", "RcppEigen", "RcppParallel", "StanHeaders"), type = "source")
install.packages(c("Rcpp", "RcppEigen", "RcppParallel", "StanHeaders"), type = "source")
install.packages("rstan", type = "source")
baymodelUCB <- brm(chosen | trials(80) ~ V*Horizon + RU*Horizon + (RU*Horizon + V*Horizon| ID), family = "binomial",
data = data[data$trial == 5, ],
chains = 2,
cores = 2,
iter = 8000)
library(brms)
install.packages("rstan", type = "source")
q()
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
install.packages("remotes")
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
macrtools::macos_rtools_install()
Latenwittchen12
macrtools::macos_rtools_uninstall()
macrtools::macos_rtools_uninstall()
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
# See if Xcode.app IDE is in use
macrtools::is_xcode_app_installed()
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
q()
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
macrtools::macos_rtools_install()
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
macrtools::macos_rtools_uninstall()
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
memory.limit(size = 4096)  # Set memory to 4GB (adjust as needed)
library(usethis)
install.packages("usethis")
library(usethis)
usethis::edit_r_environ()
#library(tidyverse)
#library(ggplot2)
library(jsonlite)
library(brms)
theme_set(theme_classic(base_size = 14))
library(tidyverse)
library(ggplot2)
#library(jsonlite)
#library(brms)
theme_set(theme_classic(base_size = 14))
setwd("/Users/kristinwitte/Documents/GitHub/exploration-psychometrics")
load("analysis/bandits/banditsWave1.Rda")
source("analysis/recovery_utils.R")
if (!is.element("KLM0", colnames(sam))) {
sam <- get_KL_into_df(sam)
save(horizon, sam, restless, file = "analysis/bandits/banditsWave1.Rda")
}
if (!is.element("bayMeanL", colnames(horizon))) {
horizon$bayMeanL <- NA
horizon$bayMeanR <- NA
horizon$bayVarL <- NA
horizon$bayVarR <- NA
horizon$row <- 1:nrow(horizon)
for (i in horizon$row[horizon$trial == 5]){
horizon[horizon$row == i, grep("bay", colnames(horizon))] <- bayIncrAtOnce(i, horizon)
}
horizon$V <- scale(getV(horizon$bayMeanL, horizon$bayMeanR))
horizon$RU <- scale(getRU(horizon$bayVarL, horizon$bayVarR))
save(horizon, sam, restless, file = "analysis/bandits/banditsWave1.Rda")
}
se<-function(x){sd(x, na.rm = T)/sqrt(length(na.omit(x)))}
meann <- function(x){mean(x, na.rm = T)}
############### Horizon task ############
horizon$Horizon <- ifelse(horizon$Horizon == 5, -0.5, 0.5)
horizon$info <- horizon$info/2
V = seq(-3, 0, 1)
RU = seq(-2, 2, 1)
Horizon = seq(-2,2,1)
VH = seq(-2,2,1)
RUH = seq(-2,2,1)
Nsims = 10
pars = data.frame(V = rep(V, each = length(RU)*length(Horizon)*length(VH)* length(RUH)),
RU = rep(RU, each = length(Horizon)*length(VH)*length(RUH)),
Horizon = rep(Horizon, each = length(VH)*length(RUH)),
VH = rep(Horizon, each = length(RUH)),
RUH = RUH,
reward = NA,
se = NA)
pars$ID <- 1:nrow(pars)
### if this is for wave 2 we don't have data for that yet so load the reward set
load("task/rewardsHorizon2.Rda")
horizon <- rewards
horizon$ID <- 1
horizon$chosen <- 99 # need this to be non na
horizon$chosen[horizon$Horizon == 5 & horizon$trial > 5] <- NA
horizon$reward <- NA
horizon$Horizon <- ifelse(horizon$Horizon == 5, -0.5, 0.5)
horizon$info <- horizon$info/2
horizon$bayMeanL <- NA
horizon$bayMeanR <- NA
horizon$bayVarL <- NA
horizon$bayVarR <- NA
library(jsonlite)
fixed <- fromJSON("task/fixedChoices2.json")# rounds incl practice * fixed choices matrix
for (i in 2:nrow(fixed)){
horizon$chosen[horizon$block == i-1 & horizon$trial < 5] <- fixed[i, ]
horizon$reward[horizon$block == i-1 & horizon$trial < 5] <- ifelse(horizon$chosen[horizon$block == i-1 & horizon$trial < 5] == 0, horizon$reward1[horizon$block == i-1 & horizon$trial < 5], horizon$reward2[horizon$block == i-1 & horizon$trial < 5])
}
########################
for (i in pars$ID){
## little progress bar
if(i %% 50 == 0){print(paste(i, "of", length(pars$ID)))}
temp <- rep(NA, Nsims)
for (k in 1:Nsims){
simdat <- subset(horizon, ID == 1 & !is.na(chosen)) # ID does not matter here, everyone observed the same fixed choices anyway
simdat$row <- 1:nrow(simdat)
for (j in simdat$row[simdat$trial > 4]){
simdat[simdat$row == j, grep("bay", colnames(simdat))] <- bayIncrAtOnce(j, simdat)
}
simdat$V <- scale(getV(simdat$bayMeanL, simdat$bayMeanR))
simdat$RU <- scale(getRU(simdat$bayVarL, simdat$bayVarR))
simdat$chosen[simdat$trial > 4] <- NA
simdat$chosen[simdat$trial == 5] <- pars$V[i] * simdat$V[simdat$trial == 5] + pars$RU[i] * simdat$RU[simdat$trial == 5] + pars$Horizon[i] * simdat$Horizon[simdat$trial == 5] +
pars$VH[i] * (simdat$V[simdat$trial == 5] * simdat$Horizon[simdat$trial == 5]) + pars$RUH[i] * (simdat$RU[simdat$trial == 5] * simdat$Horizon[simdat$trial == 5]) # setting intercept to 0 bc used scaled params so should approximately be ok
# logistic function
simdat$chosen[simdat$trial == 5] <- 1/(1+exp(-simdat$chosen[simdat$trial == 5]))
simdat$chosen[simdat$trial == 5] <- ifelse(simdat$chosen[simdat$trial == 5] < runif(nrow(simdat[simdat$trial ==5, ])), 0, 1)
simdat$reward[simdat$trial == 5] <- ifelse(simdat$chosen[simdat$trial == 5] == 0, simdat$reward1[simdat$trial == 5], simdat$reward2[simdat$trial == 5])
# update baymean and bayvar for trial 6 based on what was chosen on first free choice (5) such that can then exploit based on that outcome
for (j in simdat$row[simdat$trial == 6]){
simdat[simdat$row == j, grep("bay", colnames(simdat))] <- bayIncrAtOnce(j, simdat)
}
## make it choose optimally after trial 5
simdat$chosen[simdat$trial  == 6] <- ifelse(simdat$bayMeanL[simdat$trial == 6] > simdat$bayMeanR[simdat$trial == 6], 0, 1)
simdat$chosen[simdat$trial > 6] <- rep(simdat$chosen[simdat$trial == 6], each = 4)
simdat$best <- ifelse(simdat$reward1 > simdat$reward2, 0,1)
simdat$reward <- NA
simdat$reward <- ifelse(simdat$chosen == simdat$best, 1, 0)
temp[k] = mean(simdat$reward[simdat$trial > 4])
}
pars$reward[i] <- mean(temp)
pars$se[i] <- se(temp)
}
View(pars)
View(pars)
View(simdat)
simdat <- subset(horizon, ID == 1 & !is.na(chosen)) # ID does not matter here, everyone observed the same fixed choices anyway
simdat$row <- 1:nrow(simdat)
for (j in simdat$row[simdat$trial > 4]){
simdat[simdat$row == j, grep("bay", colnames(simdat))] <- bayIncrAtOnce(j, simdat)
}
simdat$V <- scale(getV(simdat$bayMeanL, simdat$bayMeanR))
simdat$RU <- scale(getRU(simdat$bayVarL, simdat$bayVarR))
simdat$V[simdat$trial == 5]
View(simdat)
View(simdat)

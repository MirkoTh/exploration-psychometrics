Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
Sys.setenv(MAKEFLAGS = "-j4") # four cores used
install.packages(c("Rcpp", "RcppEigen", "RcppParallel", "StanHeaders"), type = "source")
install.packages(c("Rcpp", "RcppEigen", "RcppParallel", "StanHeaders"), type = "source")
install.packages("rstan", type = "source")
baymodelUCB <- brm(chosen | trials(80) ~ V*Horizon + RU*Horizon + (RU*Horizon + V*Horizon| ID), family = "binomial",
data = data[data$trial == 5, ],
chains = 2,
cores = 2,
iter = 8000)
library(brms)
install.packages("rstan", type = "source")
q()
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
install.packages("remotes")
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
macrtools::macos_rtools_install()
Latenwittchen12
macrtools::macos_rtools_uninstall()
macrtools::macos_rtools_uninstall()
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
# See if Xcode.app IDE is in use
macrtools::is_xcode_app_installed()
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
q()
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
# install.packages("remotes")
remotes::install_github("coatless-mac/macrtools")
macrtools::macos_rtools_install()
# We can check if Xcode CLI is present using:
macrtools::is_xcode_cli_installed()
# We can verify gfortran is present as well
macrtools::is_gfortran_installed()
macrtools::macos_rtools_uninstall()
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
arch <- ifelse(R.version$arch == "aarch64", "arm64", "x86_64")
cat(paste("\nCXX14FLAGS += -O3 -mtune=native -arch", arch, "-ftemplate-depth-256"),
file = M, sep = "\n", append = FALSE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
memory.limit(size = 4096)  # Set memory to 4GB (adjust as needed)
library(usethis)
install.packages("usethis")
library(usethis)
usethis::edit_r_environ()
#library(tidyverse)
#library(ggplot2)
library(jsonlite)
library(brms)
theme_set(theme_classic(base_size = 14))
(9+7+9+6+5)*(1/1.3)
(9+7+9+6+5+8)*(1/1.3)
(9+7+9+6+5+8)*(1/1.4)
(9+7+9+6+5+8)*(1/1)
################### test retest reliabilities #################
library(plyr)
library(ggplot2)
#library(jsonlite)
library(brms)
#library(ggridges)
theme_set(theme_classic(base_size = 14))
setwd("/Users/kristinwitte/Documents/GitHub/exploration-psychometrics")
load("analysis/bandits/banditsWave1full.Rda")
horizon1 <- horizon
sam1 <- sam
restless1 <- restless
load("analysis/bandits/banditsWave2.Rda")
horizon2 <- horizon
sam2 <- sam
restless2 <- restless
##### kick out everyone that did not do second part ####
horizon1 <- subset(horizon1, is.element(ID, horizon2$ID))
horizon1$optimal <- NA # need to already add these columns bc apparently horizon2 has them
horizon1$chooseBest <- NA
horizon <- rbind(horizon1, horizon2)
sam1 <- subset(sam1, is.element(ID, sam2$ID))
sam1$optimal <- NA
sam1$chooseBest <- NA
sam <- rbind(sam1, sam2)
restless1 <- subset(restless1, is.element(ID, restless2$ID))
restless <- rbind(restless1, restless2)
#source("analysis/recovery_utils.R")
se<-function(x){sd(x, na.rm = T)/sqrt(length(na.omit(x)))}
meann <- function(x){mean(x, na.rm = T)}
rel_collect <- data.frame(task = c("horizon", "sam", "restless"),
Poptimal = NA,
regret = NA,
Pswitch = NA,
V = NA,
RU = NA,
Intercept = NA)
############### performance reliability ###########
############# P (optimal)
horizon$optimal <- ifelse(horizon$reward1 > horizon$reward2, 0, 1)
horizon$chooseBest <- ifelse(horizon$chosen == horizon$optimal, 1, 0)
Hperf <- ddply(horizon[horizon$trial > 4, ], ~ID+session,summarise, Poptim = meann(chooseBest))
sam$optimal <- ifelse(sam$reward1 > sam$reward2, 0, 1)
sam$chooseBest <- ifelse(sam$chosen == sam$optimal, 1, 0)
Sperf <- ddply(sam, ~ID + session, summarise, Poptim = meann(chooseBest))
restrewards <- subset(restless, ID == 1, c(reward1, reward2, reward3, reward4, trial, session))
restrewards$best <- apply(as.array(1:nrow(restrewards)), 1, function(x) max(c(restrewards$reward1[x],
restrewards$reward2[x],
restrewards$reward3[x],
restrewards$reward4[x])))
restless$optimalR <- restrewards$best[match(paste(restless$trial, restless$session), paste(restrewards$trial, restrewards$session))]
restless$chooseBest <- ifelse(restless$reward == restless$optimalR, 1, 0)
Rperf <- ddply(restless, ~ID+session, summarise, Poptim = meann(chooseBest))
Hperf$model <- "horizon"
Sperf$model <- "sam"
Rperf$model <- "restless"
Perfs <- rbind(Hperf, Sperf, Rperf)
models <- c("horizon", "sam", "restless")
cors <- data.frame(session1 = rep(models, length(models)),
session2 = rep(models, each = length(models)),
cor = NA)
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(Perfs$Poptim[Perfs$model == cors$session1[x] & Perfs$session == 1],
Perfs$Poptim[Perfs$model == cors$session2[x] & Perfs$session == 2], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of performance between session 1 and 2"
)
# save this for the final big plot
rel_collect$Poptimal <- cors$cor[cors$session1 == cors$session2]
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(Perfs$Poptim[Perfs$model == cors$session1[x] & Perfs$session == 1],
Perfs$Poptim[Perfs$model == cors$session2[x] & Perfs$session == 1], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of performance between bandit tasks session 1")
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(Perfs$Poptim[Perfs$model == cors$session1[x] & Perfs$session == 2],
Perfs$Poptim[Perfs$model == cors$session2[x] & Perfs$session == 2], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of performance between bandit tasks session 2")
############### regret
horizon$maxR <- ifelse(horizon$reward1 > horizon$reward2, horizon$reward1, horizon$reward2)
horizon$regret <- horizon$maxR - horizon$reward
Hperf <- ddply(horizon[horizon$trial > 4, ], ~ID+session,summarise, regret = meann(regret))
sam$maxR <- ifelse(sam$reward1 > sam$reward2, sam$reward1, sam$reward2)
sam$regret <- sam$maxR - sam$reward
Sperf <- ddply(sam, ~ID + session, summarise, regret = meann(regret))
restless$regret <-restless$optimalR - restless$reward
Rperf <- ddply(restless, ~ID+session, summarise, regret = meann(regret))
Hperf$model <- "horizon"
Sperf$model <- "sam"
Rperf$model <- "restless"
Perfs <- rbind(Hperf, Sperf, Rperf)
ggplot(Perfs, aes(regret, fill = as.factor(session))) + geom_histogram(position = "identity", alpha = 0.3) + facet_wrap(vars(model), scales = "free")
models <- c("horizon", "sam", "restless")
cors <- data.frame(session1 = rep(models, length(models)),
session2 = rep(models, each = length(models)),
cor = NA)
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(Perfs$regret[Perfs$model == cors$session1[x] & Perfs$session == 1],
Perfs$regret[Perfs$model == cors$session2[x] & Perfs$session == 2], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of performance between session 1 and 2"
)
# save this for the final big plot
rel_collect$regret <- cors$cor[cors$session1 == cors$session2]
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(Perfs$regret[Perfs$model == cors$session1[x] & Perfs$session == 1],
Perfs$regret[Perfs$model == cors$session2[x] & Perfs$session == 1], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of performance between bandit tasks session 1")
cors$cor <- apply(as.array(1:nrow(cors)), 1, function(x) cor(switch$Pswitch[switch$model == cors$session1[x] & switch$session == 2],
switch$Pswitch[switch$model == cors$session2[x] & switch$session == 2], use = "pairwise.complete.obs"))
ggplot(cors, aes(x = session1, y = session2, fill = cor)) + geom_raster() + scale_fill_gradient2(low = "red", mid = "white", high = "blue")+
geom_text(aes(label = round(cor, digits = 2))) + labs(title = "correlation of switch probability within session 2")
load("/Users/kristinwitte/Documents/GitHub/exploration-psychometrics/analysis/bandits/banditsWave2.Rda")
View(horizon)
unique(horizon$ID)
load("/Users/kristinwitte/Documents/GitHub/exploration-psychometrics/analysis/qdatWave2.Rda")
View(qdat)
unique(qdat$ID)
library(plyr)
library(ggplot2)
#library(jsonlite)
library(brms)
#library(ggridges)
theme_set(theme_classic(base_size = 14))
setwd("/Users/kristinwitte/Documents/GitHub/exploration-psychometrics")
load("analysis/bandits/banditsWave1full.Rda")
horizon1 <- horizon
sam1 <- sam
restless1 <- restless
load("analysis/bandits/banditsWave2.Rda")
horizon2 <- horizon
sam2 <- sam
restless2 <- restless
##### kick out everyone that did not do second part ####
horizon1 <- subset(horizon1, is.element(ID, horizon2$ID))
horizon1$optimal <- NA # need to already add these columns bc apparently horizon2 has them
horizon1$chooseBest <- NA
horizon <- rbind(horizon1, horizon2)
sam1 <- subset(sam1, is.element(ID, sam2$ID))
sam1$optimal <- NA
sam1$chooseBest <- NA
sam <- rbind(sam1, sam2)
restless1 <- subset(restless1, is.element(ID, restless2$ID))
restless <- rbind(restless1, restless2)
#source("analysis/recovery_utils.R")
se<-function(x){sd(x, na.rm = T)/sqrt(length(na.omit(x)))}
meann <- function(x){mean(x, na.rm = T)}
rel_collect <- data.frame(task = c("horizon", "sam", "restless"),
Poptimal = NA,
regret = NA,
Pswitch = NA,
V = NA,
RU = NA,
Intercept = NA)
load("analysis/qsWave1Full.Rda")
qdat1 <- qdat
load("analysis/qsWave2.Rda")
qdat2 <- qdat
qdat1 <- subset(qdat1, is.element(ID, qdat2$ID))
qdat2 <- subset(qdat2, is.element(ID, qdat1$ID))
qdat1$session <- 1
qdat2$session <- 2
qdat <- rbind(qdat1, qdat2)
qs <- read.csv("task/questionnaires.csv", sep = ";")
qs$Qnum <- NA
for (i in unique(qs$Measure)){
qs$Qnum[qs$Measure == i] <- 0:(nrow(qs[qs$Measure == i, ])-1)
}
qs$Q <- paste(qs$Measure, qs$Qnum, sep = "_")
responses <- tidyr::pivot_longer(qdat, cols = c(10:71), names_to = "Q", values_to = "response")
responses$attention_check <- qs$Attention.check[match(responses$Q, qs$Q)]
responses$reversed <- qs$Reverse.coded[match(responses$Q, qs$Q)]
responses <- subset(responses, attention_check == 0)
# distinguish panas positive and negative
PANASpos <- c(1,3,5,9,10,12,14,16,17,19)
PANASneg <- c(2,4,6,7,8,11,13,15,18,20)
qs$Measure[qs$Measure == "PANAS" & is.element((qs$Qnum+1), PANASpos)] <- "PANASpos"
qs$Measure[qs$Measure == "PANAS" & is.element((qs$Qnum+1), PANASneg)] <- "PANASneg"
responses$measure <- qs$Measure[match(responses$Q, qs$Q)]
library(plyr)
maxval <- ddply(responses, ~measure, summarise, max = max(response) )
responses$max <- maxval$max[match(responses$measure, maxval$measure)]
responses$response <- ifelse(responses$reversed == 1, as.numeric(responses$max) - as.numeric(responses$response), as.numeric(responses$response))
avg <- ddply(responses, ~ID+measure+session, summarise, score = mean(response))
View(avg)
write.csv(avg, "analysis/questionnaireScores.csv")
